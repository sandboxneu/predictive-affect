<!DOCTYPE html>
<html>
  <head>
    <title>Predictive Affect</title>
    <script src="node_modules/jspsych/jspsych.js"></script>
    <script src="node_modules/jspsych/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="node_modules/jspsych/plugins/jspsych-instructions.js"></script>
    <script src="node_modules/jspsych/plugins/jspsych-image-keyboard-response.js"></script>
    <script src="node_modules/jspsych/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="node_modules/jspsych/plugins/jspsych-html-slider-response.js"></script>
    <script src="assets/plugins/jspsych-html-double-slider-response.js"></script>
    <script src="utils.js"></script>
    <link href="predictiveaffect.css" rel="stylesheet" type="text/css"></link>
  </head>
  <body></body>
  <script>

  const timeline = [];
  
  // BEGIN INSTRUCTIONS

  const encodingInstructionsPanel1 = {
    type: 'html-keyboard-response',
    stimulus: 'In the first part of the experiment, a series of images will appear on the screen, one after the other.\n\nThese images will have a grey patch on them.\n\nIf you see a grey patch on the left side of the picture, please press the button \"J\" as quickly as possible. If you see a grey patch on the right side of the picture, please press the button \“K\” as quickly as possible.\n\nPlease make sure you always use the same fingers to press the buttons. \n\nYou will see many images, so we will give you breaks periodically.\n\nIf at any point of this part of the experiment that you want to quit, please press "Q".\n\nTo continue, please press "K".',
    choices: ['k'],
  };
  const encodingInstructionsPanel2 = {
    type: 'html-keyboard-response',
    stimulus: 'Next, you will see a screen with a dot representing the center. Then, the image trialing will start.\nPress "J" to continue.',
    choices: ['j'],
  };
  
  timeline.push(encodingInstructionsPanel1);
  timeline.push(encodingInstructionsPanel2);
  // END INSTRUCTIONS
  
  // CREATE TIMELINE
  
  for (block = 0; block < param['encodingBlocks']; block += 1) {
    exemplarCounts = createExemplarCounts();
    exemplarNames = Object.keys(exemplarCounts);
    for (trial = 0; trial < param['trialsPerEncodingBlock']; trial += 1) {
      // PUSH TRIAL
      
      // SELECT AN EXEMPLAR
      const curExemplar = randomlyPickFromList(exemplarNames);
      exemplarCounts[curExemplar] -= 1;
      if (exemplarCounts[curExemplar] = 0) {
        removeElement(exemplarNames, curExemplar);
      }
      // DISPLAY ITS IMAGES
      for (let subTrial = 0; subTrial < exemplars[curExemplar].getImages().length; subTrial += 1) {
        showFixationDot(timeline)
        const image = exemplars[curExemplar].getImage(subTrial);
        const saveTrial = trial;
        const curTrial = {
          type: 'html-keyboard-response',
          stimulus: generateImageHTML(image),
          choices: ['j','k'],
          trial_duration: param['display_time'] * 1000,
          response_ends_trial: false,
          on_finish: (data) => {
            data.tripletType = exemplars[curExemplar].type;
            data.tripletImages = exemplars[curExemplar].getImages().map((img) => img.fileName);
            data.trialType = 'encoding';
            data.imageAffect = image.valence;
            data.hasGreyDot = true;
            data.positionInExemplar = image.positionInExemplar;
            data.imageFile = image.fileName;
            data.trialNumber = saveTrial;
            data.greyDotX = image.greyDotX;
            data.greyDotY = image.greyDotY;
            data.key_press = jsPsych.pluginAPI.convertKeyCodeToKeyCharacter(data.key_press);
            let key = data.key_press;
            data.isCorrect = (key === 'j' && image.dotPlacement === 'left')
              || (key === 'k' && image.dotPlacement === 'right') ? 1 : 0;
          }
        }
        timeline.push(curTrial);
        trial += 1;
      }
    }
    if (block != param['encodingBlocks']) {
      showIntertrialBreak(timeline, block); // TODO change this to actually have an intertrial break
    }
  }

  // END ENCODING

  // creates a random foil for a single exemplar
  const createFoil = (curTrip, i) => {
    var result = curTrip.copy();

    const numImageTested = param['foilTestedOn'][i];
    const typeTested = param['foilTestedType'][i];
    const curType = curTrip.getImage(numImageTested).valence;

    const foilType = (curType === 'N') ? 'B' : 'N';
    var newType = (typeTested) ? foilType : curType;
    
    const imgs = (newType === 'N') ? neuImages.slice() : negImages.slice();

    var newImg;
    var newFile = result.getImage(0).fileName;

    while(curTrip.getImageNames().includes(newFile)) {
      newFile = imgs[Math.floor((Math.random() * imgs.length))];
    }

    newImg = {fileName: newFile,
            dotPlacement: 'N/A: foil',
            valence: newType,};

    result.type[numImageTested] = newType;
    result.changeImageAt(numImageTested, newImg);

    return result;
  };

  // creates a foil for every exemplar
  const createFoils = () => {
    var result = [];
    var count = 0;
    for(i in exemplars) {
      result[i] = createFoil(exemplars[i], count);
      count++;
    }
    return result;
  };

  var foils = createFoils();

  // returns the foil of the given triplet
  const getFoil = (correctTriplet, i) => {
    return foils[i];
  };

  const testingInstructions = {
    type: 'instructions',
    pages: ['<div><p>In this part of the experiment, you will see two groups of images: Group A and Group B. Each group includes three images, which will appear one after the other.</p> <p>Your job is to indicate which group looks most familiar. Please pay close attention when the images are shown, as they will not be repeated.</p> <p>First, we will show you Groups A and B. After seeing all groups, you will decide which group looks most familiar.</p><p>To start the experiment, please press "J".</p><p>To see the instructions again, please press "F".</p></div>'],
    key_forward: 'j',
  };
   
  timeline.push(testingInstructions);
  
  // displys the instructions and three images for a given triplet
  const displayTriplet = (trip, ordering) => {
    const instructText = "<div> <p> To see Group " + ordering + ", please press “J”. Three images will appear, one after the other.</p> </div>"; 

    const tripletInstructions = {
      type: 'instructions',
      pages: [instructText],
      key_forward: 'j',
    };

    timeline.push(tripletInstructions);

    for (let i = 0; i < param['imageStructLength']; i++) {
      const imgPath = getImagePath(trip.getImage(i)); 
      showFixationDot(timeline);

      const imagePrompt = {
        type: 'image-keyboard-response',
        stimulus: imgPath,
        choices: jsPsych.NO_KEYS,
        trial_duration: 1000,        
      };

      timeline.push(imagePrompt);

    }
  };

  // asks the user what the correct triplet is
  const promptCorrectTrip = (tripA, tripB, ordering) => {
    var foilDif = 0;
    var sameCat = false;
    var foil = tripA.getImages().slice();
    var correct = tripA.getImages().slice();
    const promptText = '<div><p>Using the keyboard, if the image sequence in Option A looked more familiar, press “A”.</p><p>If the image sequence in Option B looked more familiar, press “B”.</p> <p>To continue, press "Enter".</p></div>';

    for (let i = 0; i < param['imageStructLength']; i++){
      if (tripA.getImage(i).fileName != tripB.getImage(i).fileName){
        foilDif = i + 1;
        if (isNegativeImg(tripA.getImage(i)) === isNegativeImg(tripB.getImage(i))){
          sameCat = true;
        }
      }
    }

    const askPrompt = {
      type: 'html-keyboard-response',
      stimulus: promptText, 
      choices: ['a', 'b'],
      data: {'trial type': 'testing', 'triplet ordering': ordering, 'foil difference': foilDif, 'same category tested': sameCat, 'first option': tripA.getImageNames(), 'second option': tripB.getImageNames()},
      on_finish: function(data) {
          if (((ordering[0] == "correct") && (data.key_press == jsPsych.pluginAPI.convertKeyCharacterToKeyCode('a'))) ||
          ((ordering[0] == "incorrect") && (data.key_press == jsPsych.pluginAPI.convertKeyCharacterToKeyCode('b')))) {
            data.correct = 2;
          } else {
            data.correct = (sameCat) ? 1 : 0;
          }
          data['key press'] = jsPsych.pluginAPI.convertKeyCodeToKeyCharacter(data.key_press);
      }
    };

    const textPrompt = {
      type: 'instructions',
      pages: [promptText], 
      key_forward: 'enter',
    };

    timeline.push(askPrompt);
    timeline.push(textPrompt);
  }

  // for every exemplar, display the exemplar and foil
  for (i in exemplars) {
    const curTriplet = exemplars[i];
    const foil = getFoil(curTriplet, i);
    const ordering = randomlyPickBetween(["correct", "foil"], ["foil", "correct"]);
  
    const tripA = (ordering[0] === "correct") ? curTriplet : foil;
    const tripB = (tripA === curTriplet) ? foil : curTriplet;
  
    displayTriplet(tripA, "A");
    displayTriplet(tripB, "B");
    promptCorrectTrip(tripA, tripB, ordering);
  }

  const testingFinish = {
    type: 'instructions',
    pages: ['<div> <p> Thank you for finishing this part of the experiment. </p> <p>To continue, press "J".</p></div>'],
    key_forward: 'j',
  };

  timeline.push(testingFinish);

  // END TESTING

  const ratingInstructions = {
    type: 'instructions',
    pages: ['For this part of the experiment, we will show you the images you saw earlier.\n\nFor each image, you will rate how it made you feel.\n\nNote that you will not be able to quit the experiment during this part of the experiment. If you do not wish to continue, please press “Q” to quit now.\n\nTo continue, please press "J".'],
    key_forward: 'j',
   };

   timeline.push(ratingInstructions);
  

  var allImagesShown = [];

  tripletTypes.forEach(function(type) {
    allImagesShown = allImagesShown.concat(exemplars[`${type}1`].images);
    allImagesShown = allImagesShown.concat(exemplars[`${type}2`].images);
  });

  allImagesShown.forEach(function(image) {
    var trial = {
      type: 'html-double-slider-response',
      min: [0, 0],
      start: [4,4],
      max: [8,8],
      stimuli: [generateImageHTMLNoDot(image),''],
      step: [1, 1],
      labels: [],
      slider_count: 2,
      prompt: ["<p>What Valence level would you rate this image?</p>", "<p>What level of arousal would you rate this image?</p>"],
      on_finish: (data) => {
        data.Valence = data.responses[0];
        data.Arousal = data.responses[1];
        data.ImageName = image.fileName;
      }
    };
    var arousalpics = [];
    for(i = 0; i < 9; i++){
      arousalpics.push(`<img src="assets/stimuli/scale/arousal/arousal${i}.png" style="max-width:80%; filter: invert(100%);">`);
    }
    trial.labels.push(arousalpics);
    var valencepics = [];
    for(i = 0; i < 9; i++){
      valencepics.push(`<img src="assets/stimuli/scale/valence/valence${i}.png" style="max-width:80%; filter: invert(100%);">`);
    }
    trial.labels.push(valencepics);
    timeline.push(trial);
  });


  jsPsych.init({
    timeline: timeline,
    on_finish: function() {
        normalizeExemplars(exemplars).forEach((image) => jsPsych.data.get().push(image));
        jsPsych.data.get().ignore(['trial_type', 'time_elapsed', 'responses', 'stimulus', 'stimuli', 'internal_node_id', 'view_history']).localSave('csv','rating_output.csv');
        jsPsych.data.get().filterCustom((trial) => trial.trialType === 'encoding').ignore(['internal_node_id', 'trial_index', 'stimulus', 'trial_type']).localSave('csv','encoding_output.csv'); 
        jsPsych.data.get().filterCustom((trial) => trial.trialType === 'testing').ignore(['trial_type', 'time_elapsed', 'stimulus', 'internal_node_id', 'view_history', 'trial_index']).localSave('csv','testing_output.csv');
        jsPsych.data.displayData();
      }
  });

  </script>
</html>
